"""
Main application classes for the TUI.

This module contains the main ChartViewerApp and ChartQuizApp classes
that form the core of the terminal user interface for interactive
poker chart viewing and analysis.

Classes:
    ChartViewerApp: Main application for viewing and editing poker charts
    ChartQuizApp: Interactive quiz application for chart training
    ChartViewerState: Centralized state management for chart viewer

Key Features:
    - Interactive chart visualization with multiple view modes
    - Tab-based interface for managing multiple charts
    - Range builder functionality for custom ranges
    - Search and navigation capabilities
    - Export functionality to multiple formats
    - Comprehensive error handling and user feedback
"""

import asyncio
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical, ScrollableContainer
from textual.widgets import (
    Header, Footer, Static, DataTable, Button, Input,
    Select, Label, Collapsible, Pretty, TextArea, TabbedContent, TabPane
)
from textual.binding import Binding, BindingType
from typing import List, Sequence, Generator, Any
from textual.coordinate import Coordinate
from textual.message import Message
from textual.reactive import reactive
from textual import events

from typing import Dict, List, Optional, Tuple, Any, Callable
import json
from pathlib import Path
from datetime import datetime
import random
from functools import wraps

from .constants import (
    MAIN_CSS, ALL_BINDINGS, QUIZ_BINDINGS, DEFAULT_CHART_NAME,
    DEFAULT_VIEW_MODE, VIEW_MODES, SUPPORTED_EXPORT_FORMATS,
    SUPPORTED_IMPORT_FORMATS
)
from .core.error_handler import get_error_handler, handle_errors, ErrorCategory, ErrorSeverity
from .messages import (
    HandSelected, LoadChartRequested, SaveChartRequested,
    CompareChartsRequested, ExportChartRequested, ViewModeChanged,
    SearchQueryEntered, RangeBuilderToggled, HandRangeModified,
    ChartDataUpdated, QuizAnswerSelected, QuizQuestionRequested
)
from .widgets import (
    HelpDialog, HandMatrixWidget, HandDetailsWidget,
    ChartControlsWidget, ChartImportDialog
)
from .widgets.matrix import HandMatrix, HandAction, ChartAction, create_sample_range
from .core.state import ChartViewerState
from ...storage import Database, init_database





def handle_ui_errors(func: Callable) -> Callable:
    """Decorator to handle common UI errors consistently."""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except Exception as e:
            error_msg = f"❌ {func.__name__.replace('_', ' ').title()} failed: {e}"
            if hasattr(self, 'notify'):
                self.notify(error_msg, severity="error")
            else:
                print(error_msg)
            return None
    return wrapper





class ChartViewerApp(App):
    """Main chart viewer application."""

    CSS = MAIN_CSS
    BINDINGS: Sequence[BindingType] = ALL_BINDINGS

    def __init__(self, chart_name: str = DEFAULT_CHART_NAME, **kwargs):
        super().__init__(**kwargs)
        self.chart_name = chart_name
        self.state = ChartViewerState()
        self.db = init_database()
        self.error_handler = get_error_handler()

        # Setup error notification callback
        self.error_handler.set_notification_callback(self._show_error_notification)

        try:
            # Initialize with main chart
            self.state.add_chart("main", chart_name, create_sample_range())
        except Exception as e:
            self.error_handler.handle_error(
                e,
                context={'operation': 'chart_initialization', 'chart_name': chart_name},
                notify_user=True
            )

        # Performance optimizations
        self._stats_cache = {}
        self._last_chart_hash = None

        # Search functionality
        self.search_query = ""
        self.search_results = []
        self.current_search_index = -1

    @property
    def charts(self):
        """Backward compatibility property for charts."""
        return self.state.charts

    @property
    def current_tab(self):
        """Backward compatibility property for current_tab."""
        return self.state.current_chart_id

    @current_tab.setter
    def current_tab(self, value):
        self.state.switch_to_chart(value)

    @property
    def current_chart(self):
        """Backward compatibility property for current_chart."""
        return self.state.get_current_chart_data()

    @current_chart.setter
    def current_chart(self, value):
        self.state.set_current_chart_data(value)

    @property
    def current_view_mode(self):
        """Backward compatibility property for current_view_mode."""
        return self.state.view_mode

    @current_view_mode.setter
    def current_view_mode(self, value):
        self.state.set_view_mode(value)

    @property
    def help_dialog_open(self):
        """Backward compatibility property for help_dialog_open."""
        return self.state.help_dialog_open

    @help_dialog_open.setter
    def help_dialog_open(self, value):
        self.state.help_dialog_open = value

    @property
    def range_builder_mode(self):
        """Backward compatibility property for range_builder_mode."""
        return self.state.range_builder_mode

    @range_builder_mode.setter
    def range_builder_mode(self, value):
        if value:
            self.state.toggle_range_builder()
        else:
            self.state.range_builder_mode = False

    @property
    def custom_range(self):
        """Backward compatibility property for custom_range."""
        # For now, return empty dict - custom range functionality needs to be updated
        return {}

    @custom_range.setter
    def custom_range(self, value):
        # Custom range functionality needs to be implemented in new state system
        pass

    @property
    def current_action_template(self):
        """Backward compatibility property for current_action_template."""
        return ChartAction.RAISE  # Default for now

    def _get_chart_hash(self) -> str:
        """Get a hash of the current chart for caching purposes."""
        import hashlib
        chart_str = str(sorted(self.current_chart.items()))
        return hashlib.md5(chart_str.encode()).hexdigest()

    def _clear_cache(self) -> None:
        """Clear all caches when chart data changes."""
        self._stats_cache.clear()
        self._last_chart_hash = None

    def compose(self) -> ComposeResult:
        """Create the application layout with tabs."""
        yield Header()

        # Main tabbed interface
        with TabbedContent(id="chart_tabs", initial="tab_main"):
            # Main chart tab
            with TabPane("📊 Main Chart", id="tab_main"):
                with Container(classes="container"):
                    # Main panel with chart matrix
                    with Vertical(classes="main-panel"):
                        yield HandMatrixWidget(
                            self.current_chart,
                            self.chart_name,
                            id="matrix"
                        )

                    # Side panel with organized sections (details and controls stacked vertically)
                    with Vertical(classes="side-panel"):
                        # Hand details section
                        with Vertical(classes="details-section"):
                            yield Label("🃏 Hand Details", classes="section-title")
                            yield HandDetailsWidget(id="hand_details")

                        # Controls section
                        with Vertical(classes="controls-section"):
                            yield Label("🎮 Controls", classes="section-title")
                            yield ChartControlsWidget(id="controls")

            # Statistics tab
            with TabPane("📈 Statistics", id="tab_stats"):
                with Container(classes="container"):
                    with Vertical(classes="main-panel"):
                        yield Label("📊 Chart Statistics", classes="section-title")

                        # Chart statistics content
                        stats_content = f"""
Hands Defined: {len(self.current_chart)}/169 ({len(self.current_chart)/169*100:.1f}%)

Action Distribution:
{self._get_action_distribution()}

Range Analysis:
{self._get_range_analysis()}

Press 'Tab' to switch to other views
Press 'q' to quit
"""
                        yield Static(stats_content, classes="stats-content")

            # Notes tab
            with TabPane("📝 Notes", id="tab_notes"):
                with Container(classes="container"):
                    with Vertical(classes="main-panel"):
                        yield Label("📝 Strategy Notes", classes="section-title")

                        notes_content = f"""
Chart: {self.chart_name}

Current Range Notes:
• Total hands: {len(self.current_chart)}
• Focus on premium holdings
• Consider position and stack sizes
• Adapt to opponent tendencies

Key Concepts:
• Raise premium hands aggressively
• Call with marginal hands
• Fold weak holdings

Use arrow keys to navigate the matrix in Main Chart tab
Press 'Tab' to switch between tabs
Press 'q' to quit
"""
                        yield Static(notes_content, classes="notes-content")

        # Help dialog (hidden by default)
        yield HelpDialog(id="help_dialog", classes="help-dialog")

        yield Footer()

    def _get_action_distribution(self) -> str:
        """Get formatted action distribution statistics."""
        if not self.current_chart:
            return "No chart data available"

        actions_count = {}
        for hand, action in self.current_chart.items():
            action_name = action.action.value.title()
            actions_count[action_name] = actions_count.get(action_name, 0) + 1

        lines = []
        for action_name, count in sorted(actions_count.items(), key=lambda x: x[1], reverse=True):
            percentage = (count / len(self.current_chart)) * 100
            lines.append(f"• {action_name}: {count} ({percentage:.1f}%)")

        return "\n".join(lines)

    def _get_range_analysis(self) -> str:
        """Get formatted range analysis."""
        if not self.current_chart:
            return "No chart data available"

        total_hands = len(self.current_chart)
        range_percent = (total_hands / 169) * 100

        analysis_lines = [
            f"• Range Size: {range_percent:.1f}% of possible hands",
            f"• Hands in range: {total_hands}",
            f"• Hands not in range: {169 - total_hands}",
            f"• Recommendation: {'Tight' if range_percent < 15 else 'Balanced' if range_percent < 25 else 'Loose'} range"
        ]

        return "\n".join(analysis_lines)

    def _show_error_notification(self, message: str, severity: ErrorSeverity):
        """Show error notification to user."""
        # Map severity to notification style
        severity_map = {
            ErrorSeverity.LOW: "information",
            ErrorSeverity.MEDIUM: "warning",
            ErrorSeverity.HIGH: "error",
            ErrorSeverity.CRITICAL: "error"
        }

        notify_style = severity_map.get(severity, "warning")

        # Show notification
        if hasattr(self, 'notify'):
            self.notify(message, severity=notify_style)

    @handle_errors(ErrorCategory.UI_RENDERING, ErrorSeverity.HIGH)
    def on_mount(self) -> None:
        """Initialize the application."""
        self.title = f"Holdem CLI - {self.chart_name}"
        self.sub_title = "Interactive Poker Chart Viewer"

        # Focus the matrix initially
        try:
            matrix = self.query_one("#matrix", HandMatrixWidget)
            matrix.focus()
        except Exception as e:
            self.notify(f"Failed to initialize focus: {e}", severity="warning")

    @handle_errors(ErrorCategory.UI_RENDERING, ErrorSeverity.MEDIUM)
    def on_unmount(self) -> None:
        """Clean up when the application closes."""
        try:
            # Clear all caches
            self._clear_cache()

            # Clear render caches for all widgets
            self._clear_widget_caches()

            # Clear search results and state
            self._clear_search_state()

            # Clear database connection
            self._cleanup_database()

            # Log successful shutdown
            print("TUI closed successfully")
        except Exception as e:
            print(f"Error during TUI cleanup: {e}")

    def _clear_widget_caches(self) -> None:
        """Clear render caches for all matrix widgets."""
        try:
            for widget in self.query("HandMatrixWidget"):
                # Use proper Textual refresh instead of clearing internal cache
                widget.refresh()

                # Clear custom render cache if it exists
                if hasattr(widget, '_custom_render_cache'):
                    custom_cache = getattr(widget, '_custom_render_cache')
                    if hasattr(custom_cache, 'clear'):
                        custom_cache.clear()

                # Reset last actions hash if it exists
                if hasattr(widget, '_last_actions_hash'):
                    setattr(widget, '_last_actions_hash', None)
        except Exception as e:
            print(f"Warning: Could not clear widget caches: {e}")

    def _clear_search_state(self) -> None:
        """Clear search-related state."""
        self.search_query = ""
        self.search_results.clear()
        self.current_search_index = -1

    def _cleanup_database(self) -> None:
        """Clean up database connections."""
        try:
            if hasattr(self.db, 'close'):
                self.db.close()
        except Exception as e:
            print(f"Warning: Could not close database connection: {e}")

    def on_hand_selected(self, message: HandSelected) -> None:
        """Handle hand selection."""
        hand_details = self.query_one("#hand_details", HandDetailsWidget)
        matrix = self.query_one("#matrix", HandMatrixWidget)

        action = matrix.actions.get(message.hand)
        hand_details.update_hand(message.hand, action)

    def on_load_chart_requested(self, message: LoadChartRequested) -> None:
        """Handle load chart request."""
        try:
            # For now, just load a different sample chart
            self.current_chart = self._create_tight_range()
            self._update_matrix()
            self.notify("✅ Tight range loaded successfully", severity="information")
        except Exception as e:
            self.notify(f"❌ Failed to load chart: {e}", severity="error")

    def on_save_chart_requested(self, message: SaveChartRequested) -> None:
        """Handle save chart request."""
        # Save current chart to database
        try:
            if not self.current_chart:
                self.notify("⚠️ No chart data to save", severity="warning")
                return

            chart_data = {
                hand: {
                    "action": action.action.value,
                    "frequency": action.frequency,
                    "ev": action.ev,
                    "notes": action.notes
                }
                for hand, action in self.current_chart.items()
            }

            # In a real implementation, save to database
            self.notify(f"✅ Chart saved successfully! ({len(self.current_chart)} hands)", severity="information")
        except Exception as e:
            self.notify(f"❌ Error saving chart: {e}", severity="error")

    def on_compare_charts_requested(self, message: CompareChartsRequested) -> None:
        """Handle compare charts request."""
        try:
            # Create a comparison range (loose range for demo)
            comparison_range = self._create_loose_range()

            # Create comparison data
            differences = self._analyze_chart_differences(self.current_chart, comparison_range)

            # Display comparison results
            self._show_comparison_results(differences, len(self.current_chart), len(comparison_range))
        except Exception as e:
            self.notify(f"❌ Comparison failed: {e}", severity="error")

    def _analyze_chart_differences(self, chart1: Dict[str, HandAction], chart2: Dict[str, HandAction]) -> Dict[str, Any]:
        """Analyze differences between two charts."""
        differences = {
            'only_in_chart1': [],
            'only_in_chart2': [],
            'different_actions': [],
            'same_actions': []
        }

        all_hands = set(chart1.keys()) | set(chart2.keys())

        for hand in all_hands:
            in_chart1 = hand in chart1
            in_chart2 = hand in chart2

            if in_chart1 and not in_chart2:
                differences['only_in_chart1'].append(hand)
            elif in_chart2 and not in_chart1:
                differences['only_in_chart2'].append(hand)
            elif in_chart1 and in_chart2:
                action1 = chart1[hand]
                action2 = chart2[hand]

                if (action1.action != action2.action or
                    abs(action1.frequency - action2.frequency) > 0.1):
                    differences['different_actions'].append({
                        'hand': hand,
                        'chart1_action': action1,
                        'chart2_action': action2
                    })
                else:
                    differences['same_actions'].append(hand)

        return differences

    def _show_comparison_results(self, differences: Dict[str, Any], size1: int, size2: int) -> None:
        """Display comparison results in a user-friendly format."""
        lines = [
            "📊 Chart Comparison Results",
            "=" * 40,
            f"Chart 1: {size1} hands",
            f"Chart 2: {size2} hands",
            "",
            "🔍 Analysis:"
        ]

        # Show differences
        if differences['only_in_chart1']:
            lines.append(f"✅ Only in Chart 1: {len(differences['only_in_chart1'])} hands")
            if len(differences['only_in_chart1']) <= 10:
                lines.append(f"   Hands: {', '.join(differences['only_in_chart1'][:10])}")

        if differences['only_in_chart2']:
            lines.append(f"✅ Only in Chart 2: {len(differences['only_in_chart2'])} hands")
            if len(differences['only_in_chart2']) <= 10:
                lines.append(f"   Hands: {', '.join(differences['only_in_chart2'][:10])}")

        if differences['different_actions']:
            lines.append(f"⚖️ Different actions: {len(differences['different_actions'])} hands")
            # Show first few differences
            for diff in differences['different_actions'][:5]:
                hand = diff['hand']
                action1 = diff['chart1_action']
                action2 = diff['chart2_action']
                lines.append(f"   {hand}: {action1.action.value} vs {action2.action.value}")

        if differences['same_actions']:
            lines.append(f"🤝 Same actions: {len(differences['same_actions'])} hands")

        # Show summary
        total_differences = (len(differences['only_in_chart1']) +
                           len(differences['only_in_chart2']) +
                           len(differences['different_actions']))

        lines.extend([
            "",
            "📈 Summary:",
            f"Total differences: {total_differences}",
            f"Similarity: {((size1 + size2 - total_differences) / (size1 + size2) * 100):.1f}%"
        ])

        self.notify("\n".join(lines), timeout=15)

    def on_export_chart_requested(self, message: ExportChartRequested) -> None:
        """Handle export chart request."""
        try:
            if not self.current_chart:
                self.notify("⚠️ No chart data to export", severity="warning")
                return

            # Export in multiple formats
            exported_files = self._export_chart_in_multiple_formats()
            self._notify_export_success(exported_files)

        except PermissionError:
            self.notify("❌ Permission denied. Cannot write to file", severity="error")
        except OSError as e:
            self.notify(f"❌ File system error: {e}", severity="error")
        except Exception as e:
            self.notify(f"❌ Error exporting chart: {e}", severity="error")

    def _export_chart_in_multiple_formats(self) -> List[str]:
        """Export chart in multiple formats and return list of exported file paths."""
        base_name = self.chart_name.lower().replace(' ', '_')
        matrix = HandMatrix(self.current_chart, self.chart_name)
        exported_files = []

        # Export to text file
        txt_path = f"{base_name}.txt"
        matrix.export_to_text(txt_path)
        exported_files.append(txt_path)

        # Export to JSON
        json_path = f"{base_name}.json"
        self._export_to_json(json_path)
        exported_files.append(json_path)

        # Export to CSV
        csv_path = f"{base_name}.csv"
        self._export_to_csv(csv_path)
        exported_files.append(csv_path)

        return exported_files

    def _notify_export_success(self, exported_files: List[str]) -> None:
        """Notify user of successful export with file list."""
        file_list = "\n   ".join(f"📄 {path}" for path in exported_files)
        self.notify(f"✅ Chart exported in {len(exported_files)} formats:\n   {file_list}\n   ({len(self.current_chart)} hands)", severity="information")

    @handle_ui_errors
    def action_new_chart_tab(self) -> None:
        """Create a new chart tab."""
        tab_id, tab_name = self._generate_tab_id()

        # Create new chart data
        self._create_chart_data(tab_id, tab_name)

        # Create and setup the tab UI
        tab_pane = self._create_tab_pane(tab_id, tab_name)
        self._setup_tab_content(tab_pane, tab_id, tab_name)

        # Switch to the new tab
        self._switch_to_new_tab(tab_id, tab_name)

    def _generate_tab_id(self) -> Tuple[str, str]:
        """Generate unique tab ID and name."""
        return self.state.generate_tab_id()

    def _create_chart_data(self, tab_id: str, tab_name: str) -> None:
        """Create new chart data for the tab."""
        self.state.add_chart_tab(tab_id, tab_name)

    def _create_tab_pane(self, tab_id: str, tab_name: str) -> TabPane:
        """Create and add new tab pane to the tabbed content."""
        tabs = self.query_one("#chart_tabs", TabbedContent)
        tab_pane = TabPane(f"📊 {tab_name}", id=f"tab_{tab_id}")
        tabs.add_pane(tab_pane)
        return tab_pane

    def _setup_tab_content(self, tab_pane: TabPane, tab_id: str, tab_name: str) -> None:
        """Setup the content and widgets for the new tab."""
        new_container = Container(classes="container")

        # Main panel with chart matrix
        main_panel = self._create_main_panel(tab_id, tab_name)
        new_container.mount(main_panel)

        # Side panel with organized sections
        side_panel = self._create_side_panel(tab_id)
        new_container.mount(side_panel)

        tab_pane.mount(new_container)

    def _create_main_panel(self, tab_id: str, tab_name: str) -> Vertical:
        """Create the main panel with chart matrix widget."""
        main_panel = Vertical(classes="main-panel")
        main_panel.mount(HandMatrixWidget(
            self.charts[tab_id]["chart"],
            tab_name,
            id=f"matrix_{tab_id}"
        ))
        return main_panel

    def _create_side_panel(self, tab_id: str) -> Vertical:
        """Create the side panel with hand details and controls sections."""
        side_panel = Vertical(classes="side-panel")

        # Hand details section
        details_section = Vertical(classes="details-section")
        details_section.mount(Label("🃏 Hand Details", classes="section-title"))
        details_section.mount(HandDetailsWidget(id=f"hand_details_{tab_id}"))
        side_panel.mount(details_section)

        # Controls section
        controls_section = Vertical(classes="controls-section")
        controls_section.mount(Label("🎮 Controls", classes="section-title"))
        controls_section.mount(ChartControlsWidget(id=f"controls_{tab_id}"))
        side_panel.mount(controls_section)

        return side_panel

    def _switch_to_new_tab(self, tab_id: str, tab_name: str) -> None:
        """Switch to the newly created tab and notify user."""
        tabs = self.query_one("#chart_tabs", TabbedContent)
        tabs.active = f"tab_{tab_id}"
        self.current_tab = tab_id
        self.notify(f"✅ Created new chart tab: {tab_name}", severity="information")

    @handle_ui_errors
    def action_close_current_tab(self) -> None:
        """Close the current tab."""
        if self.current_tab == "main":
            self.notify("⚠️ Cannot close the main chart tab", severity="warning")
            return

        self._close_tab(self.current_tab)
        self._switch_to_main_tab()
        self.notify("✅ Tab closed", severity="information")

    def _close_tab(self, tab_id: str) -> None:
        """Remove a specific tab and its data."""
        tabs = self.query_one("#chart_tabs", TabbedContent)
        tab_pane_id = f"tab_{tab_id}"
        tabs.remove_pane(tab_pane_id)
        self.state.remove_chart_tab(tab_id)

    def _switch_to_main_tab(self) -> None:
        """Switch back to the main tab."""
        tabs = self.query_one("#chart_tabs", TabbedContent)
        self.current_tab = "main"
        tabs.active = "tab_main"

    def action_switch_to_tab(self, tab_name: str) -> None:
        """Switch to a specific tab."""
        tabs = self.query_one("#chart_tabs", TabbedContent)

        if tab_name == "main":
            tabs.active = "tab_main"
            self.current_tab = "main"
        elif tab_name == "stats":
            tabs.active = "tab_stats"
        elif tab_name == "notes":
            tabs.active = "tab_notes"
        else:
            # Switch to a chart tab
            tab_id = f"tab_{tab_name}"
            if tab_id in [pane.id for pane in tabs.query("TabPane").results()]:
                tabs.active = tab_id
                self.current_tab = tab_name

    def on_view_mode_changed(self, message: ViewModeChanged) -> None:
        """Handle view mode change."""
        old_mode = self.current_view_mode
        self.current_view_mode = message.mode

        # Update the matrix widget with new view mode
        try:
            matrix = self.query_one("#matrix", HandMatrixWidget)
            matrix.view_mode = message.mode
            matrix.refresh()
            self.notify(f"✅ Switched to {message.mode.title()} view", severity="information")
        except Exception as e:
            self.notify(f"❌ Failed to switch view mode: {e}", severity="error")
            self.current_view_mode = old_mode

    def action_help(self) -> None:
        """Toggle help dialog."""
        try:
            help_dialog = self.query_one("#help_dialog", HelpDialog)

            if self.help_dialog_open:
                # Close help dialog
                help_dialog.remove_class("open")
                self.help_dialog_open = False
                self.notify("Help closed", severity="information", timeout=2)
            else:
                # Open help dialog
                help_dialog.add_class("open")
                self.help_dialog_open = True
                self.notify("Press H or Escape to close help", severity="information", timeout=3)
        except Exception as e:
            self.notify(f"Error toggling help: {e}", severity="error")

    def action_jump_position(self, position: str) -> None:
        """Jump to position-specific chart."""
        self.notify(f"Jumping to {position} position", severity="information")
        # In a real implementation, load position-specific chart

    def action_navigate_matrix(self, direction: str) -> None:
        """Navigate the matrix in the specified direction with enhanced feedback."""
        try:
            matrix = self.query_one("#matrix", HandMatrixWidget)

            # Store old position for feedback
            old_row, old_col = matrix.selected_row, matrix.selected_col
            old_hand = matrix.get_selected_hand()

            # Navigate to new position
            if direction == "up":
                matrix.selected_row = max(0, matrix.selected_row - 1)
            elif direction == "down":
                matrix.selected_row = min(12, matrix.selected_row + 1)
            elif direction == "left":
                matrix.selected_col = max(0, matrix.selected_col - 1)
            elif direction == "right":
                matrix.selected_col = min(12, matrix.selected_col + 1)
            else:
                self.notify(f"⚠️ Unknown direction: {direction}", severity="warning")
                return

            # Get new position info
            new_hand = matrix.get_selected_hand()
            new_action = matrix.actions.get(new_hand)

            # Update hand details
            hand_details = self.query_one("#hand_details", HandDetailsWidget)
            hand_details.update_hand(new_hand, new_action)

            # Provide navigation feedback
            self._provide_navigation_feedback(old_hand, new_hand, new_action, direction)

        except Exception as e:
            self.notify(f"❌ Navigation error: {e}", severity="error")

    def _provide_navigation_feedback(self, old_hand: str, new_hand: str, action: Optional[HandAction], direction: str) -> None:
        """Provide user feedback for navigation actions."""
        if action:
            action_emoji = {"raise": "🔴", "call": "🟢", "fold": "⚫", "mixed": "🟡", "bluff": "🔵"}.get(action.action.value, "⚪")
            frequency_info = f" ({action.frequency:.0%})" if action.frequency < 1.0 else ""
            self.notify(f"{action_emoji} {new_hand}: {action.action.value.title()}{frequency_info}", severity="information", timeout=1)
        else:
            self.notify(f"⚪ {new_hand}: No action defined", severity="information", timeout=1)

    def action_select_hand(self) -> None:
        """Select the currently highlighted hand."""
        matrix = self.query_one("#matrix", HandMatrixWidget)
        hand = matrix.get_selected_hand()
        self.on_hand_selected(HandSelected(hand))

    def action_reset_view(self) -> None:
        """Reset the view to the default state."""
        matrix = self.query_one("#matrix", HandMatrixWidget)
        matrix.selected_row = 0
        matrix.selected_col = 0
        hand_details = self.query_one("#hand_details", HandDetailsWidget)
        hand_details.update_hand("", None)
        self.notify("View reset", severity="information")

    def action_toggle_frequency(self) -> None:
        """Toggle frequency-based view."""
        self.on_view_mode_changed(ViewModeChanged("frequency"))

    def action_toggle_ev_view(self) -> None:
        """Toggle EV-based view."""
        self.on_view_mode_changed(ViewModeChanged("ev"))

    def action_refresh_data(self) -> None:
        """Refresh the chart data."""
        matrix = self.query_one("#matrix", HandMatrixWidget)
        matrix.refresh()
        self.notify("Data refreshed", severity="information")

    def action_undo_action(self) -> None:
        """Undo the last action."""
        self.notify("Undo not yet implemented", severity="warning")

    def action_close_help_or_clear(self) -> None:
        """Close help dialog or clear selection."""
        if self.help_dialog_open:
            # Close help dialog
            self.action_help()
        else:
            # Clear selection
            self.action_clear_selection()

    def action_clear_selection(self) -> None:
        """Clear the current selection."""
        hand_details = self.query_one("#hand_details", HandDetailsWidget)
        hand_details.update_hand("", None)
        self.notify("Selection cleared", severity="information")

    def action_cycle_view_mode(self) -> None:
        """Cycle through different view modes."""
        current_index = VIEW_MODES.index(self.current_view_mode)
        next_index = (current_index + 1) % len(VIEW_MODES)
        next_mode = VIEW_MODES[next_index]
        self.on_view_mode_changed(ViewModeChanged(next_mode))

    def action_search_hands(self) -> None:
        """Search for hands in the chart."""
        def handle_search_result(query: str) -> None:
            if query:
                self._perform_search(query)
            else:
                self.search_query = ""
                self.search_results = []
                self.current_search_index = -1
                self.notify("Search cleared", severity="information")

        # In a real implementation, you'd open a search dialog
        # For now, we'll simulate with a notification
        self.notify("🔍 Enter search query (e.g., 'AK', 'suited', 'raise')", severity="information")

        # Example search - in practice you'd get this from user input
        example_queries = ["AK", "suited", "raise", "JJ"]
        example_query = example_queries[len(self.search_results) % len(example_queries)]
        self._perform_search(example_query)

    def action_next_search_result(self) -> None:
        """Navigate to next search result."""
        if not self.search_results:
            self.notify("No search results to navigate", severity="warning")
            return

        self.current_search_index = (self.current_search_index + 1) % len(self.search_results)
        self._highlight_search_result()

    def action_prev_search_result(self) -> None:
        """Navigate to previous search result."""
        if not self.search_results:
            self.notify("No search results to navigate", severity="warning")
            return

        self.current_search_index = (self.current_search_index - 1) % len(self.search_results)
        self._highlight_search_result()

    def _perform_search(self, query: str) -> None:
        """Perform search and store results."""
        self.search_query = query.lower()
        self.search_results = []
        self.current_search_index = -1

        for hand, action in self.current_chart.items():
            if self._hand_matches_query(hand, action, self.search_query):
                self.search_results.append(hand)

        if self.search_results:
            self.current_search_index = 0
            self._highlight_search_result()
            self.notify(f"🔍 Found {len(self.search_results)} hands matching '{query}'", severity="information")
        else:
            self.notify(f"❌ No hands found matching '{query}'", severity="warning")

    def _hand_matches_query(self, hand: str, action: HandAction, query: str) -> bool:
        """Check if a hand matches the search query."""
        # Hand name matching
        if query in hand.lower():
            return True

        # Action matching
        if query in action.action.value.lower():
            return True

        # Suited/offsuit matching
        if "suited" in query and hand.endswith("s"):
            return True
        if "offsuit" in query and hand.endswith("o"):
            return True
        if "pocket" in query and hand[0] == hand[1]:
            return True

        # Rank matching (e.g., "broadway", "high", "low")
        if "broadway" in query and hand[0] in "AKQJT":
            return True
        if "high" in query and hand[0] in "AKQJ":
            return True
        if "low" in query and hand[0] in "23456":
            return True

        # Connector matching
        if "connector" in query and self._is_connector(hand):
            return True

        return False

    def _is_connector(self, hand: str) -> bool:
        """Check if hand is a connector."""
        if len(hand) != 3 or hand[2] not in "so":
            return False

        ranks = "23456789TJQKA"
        try:
            pos1 = ranks.index(hand[0])
            pos2 = ranks.index(hand[1])
            return abs(pos1 - pos2) <= 1
        except ValueError:
            return False

    def _highlight_search_result(self) -> None:
        """Highlight the current search result."""
        if not self.search_results or self.current_search_index < 0:
            return

        hand = self.search_results[self.current_search_index]
        action = self.current_chart.get(hand)

        if action:
            # Navigate to the hand's position in the matrix
            matrix = self.query_one("#matrix", HandMatrixWidget)

            # Find hand position in matrix
            for row in range(13):
                for col in range(13):
                    matrix_hand = matrix.matrix.get_hand_at_position(row, col)
                    if matrix_hand == hand:
                        matrix.selected_row = row
                        matrix.selected_col = col

                        # Update hand details
                        hand_details = self.query_one("#hand_details", HandDetailsWidget)
                        hand_details.update_hand(hand, action)
                        return

            self.notify(f"Highlighted: {hand} ({self.current_search_index + 1}/{len(self.search_results)})", severity="information")

    def action_toggle_range_builder(self) -> None:
        """Toggle range builder mode."""
        self.range_builder_mode = not self.range_builder_mode

        if self.range_builder_mode:
            self.notify("🔧 Range Builder enabled - Use A/D to add/remove hands, B to toggle, C to clear", severity="information")
        else:
            self.notify("📊 Range Builder disabled - View mode restored", severity="information")

        # Update the display
        matrix = self.query_one("#matrix", HandMatrixWidget)
        matrix.range_builder_mode = self.range_builder_mode
        matrix.custom_range = self.custom_range
        matrix.refresh()

    def action_add_hand_to_range(self) -> None:
        """Add currently selected hand to custom range."""
        if not self.range_builder_mode:
            return

        matrix = self.query_one("#matrix", HandMatrixWidget)
        hand = matrix.get_selected_hand()

        if hand:
            # Create action based on current template
            action = HandAction(
                action=self.current_action_template,
                frequency=1.0,
                ev=0.5,
                notes=f"Added via range builder"
            )
            self.custom_range[hand] = action

            # Update display
            matrix.custom_range = self.custom_range
            matrix.refresh()

            self.notify(f"✅ Added {hand} to custom range", severity="information")

    def action_remove_hand_from_range(self) -> None:
        """Remove currently selected hand from custom range."""
        if not self.range_builder_mode:
            return

        matrix = self.query_one("#matrix", HandMatrixWidget)
        hand = matrix.get_selected_hand()

        if hand and hand in self.custom_range:
            del self.custom_range[hand]

            # Update display
            matrix.custom_range = self.custom_range
            matrix.refresh()

            self.notify(f"❌ Removed {hand} from custom range", severity="information")
        else:
            self.notify(f"⚠️ {hand} not in custom range", severity="warning")

    def action_clear_custom_range(self) -> None:
        """Clear the custom range."""
        if not self.range_builder_mode:
            return

        self.custom_range.clear()

        # Update display
        matrix = self.query_one("#matrix", HandMatrixWidget)
        matrix.custom_range = self.custom_range
        matrix.refresh()

        self.notify("🗑️ Custom range cleared", severity="information")

    def action_load_chart(self) -> None:
        """Load chart action."""
        self.on_load_chart_requested(LoadChartRequested())

    def action_save_chart(self) -> None:
        """Save chart action."""
        self.on_save_chart_requested(SaveChartRequested())

    def action_compare_charts(self) -> None:
        """Compare charts action."""
        self.on_compare_charts_requested(CompareChartsRequested())

    def action_export_chart(self) -> None:
        """Export chart action."""
        self.on_export_chart_requested(ExportChartRequested())

    def _update_matrix(self) -> None:
        """Update the matrix widget with new chart data."""
        try:
            current_hash = self._get_chart_hash()

            # Only update if chart has changed
            if current_hash != self._last_chart_hash:
                matrix = self.query_one("#matrix", HandMatrixWidget)
                matrix.actions = self.current_chart
                matrix.matrix = HandMatrix(self.current_chart, self.chart_name)
                matrix._last_actions_hash = current_hash  # Update matrix cache

                # Clear custom render cache instead of internal _render_cache
                if hasattr(matrix, '_custom_render_cache'):
                    matrix._custom_render_cache.clear()

                matrix.refresh()

                # Update our cache
                self._last_chart_hash = current_hash
                self._clear_cache()
            else:
                # Just refresh the display
                matrix = self.query_one("#matrix", HandMatrixWidget)
                matrix.refresh()
        except Exception as e:
            self.notify(f"❌ Failed to update matrix: {e}", severity="error")

    def _create_tight_range(self) -> Dict[str, HandAction]:
        """Create a tight playing range for demonstration."""
        tight_range = {}

        # Very premium hands only
        premium = ["AA", "KK", "QQ", "JJ", "AKs", "AKo"]
        for hand in premium:
            tight_range[hand] = HandAction(ChartAction.RAISE, frequency=1.0, ev=3.0)

        # Some medium pairs
        medium = ["TT", "99"]
        for hand in medium:
            tight_range[hand] = HandAction(ChartAction.CALL, frequency=1.0, ev=1.0)

        return tight_range

    def _create_loose_range(self) -> Dict[str, HandAction]:
        """Create a loose playing range for demonstration."""
        loose_range = {}

        # Many more hands
        raise_hands = ["AA", "KK", "QQ", "JJ", "TT", "99", "88", "77",
                      "AKs", "AKo", "AQs", "AQo", "AJs", "AJo", "ATs"]
        for hand in raise_hands:
            loose_range[hand] = HandAction(ChartAction.RAISE, frequency=0.8, ev=1.5)

        call_hands = ["66", "55", "44", "33", "22", "KQs", "KQo", "KJs",
                     "QJs", "JTs", "A9s", "A8s", "A7s", "A6s", "A5s"]
        for hand in call_hands:
            loose_range[hand] = HandAction(ChartAction.CALL, frequency=1.0, ev=0.5)

        return loose_range

    def _export_to_json(self, filepath: str) -> None:
        """Export chart data to JSON format."""
        import json
        from datetime import datetime

        export_data = {
            "name": self.chart_name,
            "export_format": "holdem-cli-v1",
            "export_timestamp": datetime.now().isoformat(),
            "total_hands": len(self.current_chart),
            "ranges": {
                hand: {
                    "action": action.action.value,
                    "frequency": action.frequency,
                    "ev": action.ev,
                    "notes": action.notes
                }
                for hand, action in self.current_chart.items()
            }
        }

        with open(filepath, 'w') as f:
            json.dump(export_data, f, indent=2)

    def _export_to_csv(self, filepath: str) -> None:
        """Export chart data to CSV format."""
        import csv

        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Hand', 'Action', 'Frequency', 'EV', 'Notes'])

            for hand, action in sorted(self.current_chart.items()):
                writer.writerow([
                    hand,
                    action.action.value,
                    action.frequency,
                    action.ev or '',
                    action.notes
                ])
